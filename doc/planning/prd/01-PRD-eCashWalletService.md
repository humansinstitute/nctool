# Simple NIP-60/NIP-61 eCash Wallet Service Design

## Overview of NIP-60 (Nutstash) and NIP-61 (Nutzaps)  
**NIP-60 (Nutstash):** Defines a _portable Cashu wallet_ that stores its data on Nostr relays. In practice, this means the user's eCash tokens (Cashu proofs) and wallet info are saved as Nostr events (encrypted so only the user can read them). This makes the wallet accessible across different clients without a separate backend database – the Nostr network is the primary storage ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=1,only%20and%20is%20completely%20optional)).  

**NIP-61 (Nutzaps):** Defines **Nutzaps**, an instant way to send tips or payments (like Nostr “zaps”) using eCash tokens. A Nutzap is essentially a Cashu token locked to the recipient’s public key (P2PK) and posted as a Nostr event. Only the recipient (with the corresponding private key) can redeem that token ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=,kind%3A10019)). This enables off-chain Lightning-like tips via Nostr without needing an immediate Lightning payment.  

**Context:** We will design a simple backend wallet service (Node/Express) that implements these NIPs. The service will interact with: 

- **Nostr relays** for storing/fetching wallet data and payment events.  
- **A Cashu Mint** (Chaumian eCash server) for issuing and verifying eCash tokens.  
- **MongoDB** (optional, for transient state) – not the primary storage, but can cache inflight info if needed.  
- **CLI frontend** Slim CLI that calls the backend API.  

The goal is to keep things simple and easy to follow, prioritizing clarity over edge-case optimizations. We'll assume a single trusted Cashu mint is used for all operations (no multi-mint complexity). Encryption, signing, and other crypto details will be handled by libraries so the developer doesn’t need to reimplement them from scratch.

## Architecture & Interaction Flow  
At a high level, the components interact as follows:  

1. **User (CLI Frontend)** – Initiates actions (create wallet, send payment, check balance, etc.) by selecting on a simple menu and triggering HTTP requests to the backend API. The user is identified by their Nostr keys for the specific session we are running (public/private key pair) which the client uses for signing directly, or integrates with a NostrMQ signer (future state).
2. **MERN Backend (Node/Express)** – Implements wallet logic. It uses a Cashu library to handle eCash operations and a Nostr library to publish and retrieve events. Key responsibilities:  
   - **Managing Nostr Events:** Publishing the user’s wallet event and token events to Nostr (and decrypting/encrypting them as needed). Also reading incoming Nutzap events from Nostr.  
   - **Interfacing with Cashu Mint:** Requesting new tokens, splitting/combining tokens, and verifying or redeeming tokens by calling the mint’s API.  
3. **Nostr Relays** – Network servers that store events. The wallet service will publish certain kinds of events to relays and query relays for relevant events. According to NIP-60/61, we will use custom event kinds: 
   - **Wallet metadata event:** kind `17375` – contains encrypted wallet info (like which mint it uses and the wallet’s P2PK privkey) ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=%2A%20%60mint%60%20,61%20nutzaps)).  
   - **Token events (Nutstash):** kind `7375` – contain the user’s **unspent eCash proofs**, encrypted so only the user can read them ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=1,only%20and%20is%20completely%20optional)) ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=%7B%20,1)). These represent the “stash” of coins.  
   - **Spending log events:** kind `7376` – optional, for recording history of spends/receipts (for user display, not needed for functionality) ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=1,only%20and%20is%20completely%20optional)).  
   - **Nutzap info event:** kind `10019` – an advertisement of how the user can receive payments. It lists the relays the user listens on, the mint(s) they accept, and the **public key** that others should use to lock payments to them ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=%7B%20,pubkey%3E%22%20%5D)) ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=,lock%20receiving%20nutzaps)). (This pubkey corresponds to the wallet’s P2PK privkey in the kind 17375 event, and is **not** the user’s main Nostr pubkey for security).  
   - **Nutzap payment event:** kind `9321` – used when sending a payment. It includes the token proofs (as JSON in a `proof` tag) and tags referencing the recipient and (optionally) the post being “zapped” ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=Nutzap%20event)). The token is **P2PK-locked** to the recipient’s pubkey from their 10019 event, so only they can redeem it ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=,kind%3A10019)).  
4. **Cashu Mint** – A server that actually issues and verifies eCash tokens (satoshis represented as blinded tokens). The backend will communicate with the mint over HTTP (e.g., endpoints like `/mint`, `/split`, `/melt`, etc.). For example, when creating a new token or verifying a received token, the backend calls the mint’s API. The mint is assumed to support **NUT-11 (P2PK)** and related extensions so that P2PK-locked tokens and their redemption (via DLEQ proofs) are possible ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=match%20at%20L369%201,65)).  Assume 
5. **MongoDB (Transient)** – While not strictly necessary, the backend can use MongoDB to cache things like the latest known balance, pending sends, or to mirror Nostr events for faster lookup. For simplicity, one might start without relying on Mongo at all (just query Nostr and the mint as needed). Mongo can later optimize performance (e.g., storing last seen event IDs to poll for new ones, or caching decrypted tokens so we don’t re-decrypt every time).

**Step-by-Step Interaction (General):** When a user triggers an action, the request goes to the Node backend. The backend might do one or more of the following: sign or decrypt using the user’s keys, call the Cashu mint’s API for eCash operations, and publish or fetch events on Nostr relays. The result is returned to the frontend (e.g., success/failure and any data like updated balance). Below, we’ll detail specific flows for creating a wallet, receiving funds, and spending (sending funds).

## API Endpoints Design  
We will expose a simple RESTful API in the Express backend for wallet operations. The API could look like:  

- **`POST /wallet/create`** – Initializes a new NIP-60 wallet for the user.  
- **`GET /wallet/balance`** (or as part of `/wallet` state) – Retrieves current balance and wallet info (by reading Nostr events). *(Optional but useful)*  
- **`POST /wallet/receive`** – Processes an incoming token (either via Nostr Nutzap or a provided token string) and adds it to the user’s wallet.  
- **`POST /wallet/spend`** – Creates a payment: either sending a Nutzap to another Nostr user or withdrawing a token to a string/Lightning invoice.  

For clarity, we focus on `createWallet`, `receive`, and `spend` as requested. The API should be stateless (each call provides needed auth like the user’s Nostr private key or uses an active session) so the service can reconstruct state from Nostr if needed.

### `POST /wallet/create`  
**Purpose:** Set up a new eCash wallet tied to the user’s Nostr identity. Only call this once per user (subsequent calls would detect an existing wallet).  

**Process:**  
1. **Generate Wallet Key:** The backend generates a new **wallet private key** for receiving P2PK tokens (this is not the Nostr login key; it’s a separate key just for eCash, per NIP-60 ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=%2A%20%60mint%60%20,61%20nutzaps))). For example, use a cryptographic random generator to make a 32-byte key. Derive its public key (we’ll use that in the info event).  
2. **Prepare Wallet Event (kind 17375):** This JSON event contains the wallet’s basics, encrypted with the user’s Nostr key (using NIP-44 encryption so that only the user can decrypt it later). The content includes:  
   - The wallet’s new P2PK **privkey** (in hex or base64) – stored encrypted ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=%2A%20%60mint%60%20,61%20nutzaps)).  
   - The Cashu **mint URL** (and possibly any backup mints) the wallet will use ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=%2A%20%60mint%60%20,61%20nutzaps)).  
   These are put in an array or object and then encrypted. The event is marked as kind 17375 and as a **replaceable** event (so if we update the wallet info later, it supersedes the old one). Sign this event with the user’s Nostr key and publish it to relays.  
3. **Prepare Nutzap Info Event (kind 10019):** This is recommended if the user wants to receive payments from others. It’s basically the user’s “address” on Nostr for payments ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=,lock%20receiving%20nutzaps)). We include in its tags:  
   - One or more `relay` tags: the URLs of relays where the user will be listening for payment events. (Peers should post Nutzap events to these relays to ensure the user gets them.)  
   - One or more `mint` tags: the URL of the Cashu mint the user accepts, and optionally the unit (e.g., “sat” for satoshis) ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=%5B%20,pubkey%3E%22%20%5D%20%5D)). Since we assume a single mint, list that one.  
   - A `pubkey` tag: the **public key** corresponding to the wallet privkey generated in step 1 ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=%5B%20,pubkey%3E%22%20%5D%20%5D)) ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=,60%20wallet%20event)). This is the key others will use to lock tokens to the user. (Important: as specified, this must NOT be the user’s main Nostr pubkey – it’s the dedicated wallet pubkey.)  
   This event is kind 10019 (an ordinary event type, not replaceable in spec, but it can be resent if needed). Sign with user’s Nostr key and publish to relays.  
4. **Confirmation:** Return a response to the client indicating success. You might include the wallet’s public info (e.g., the mint URL and the receiving pubkey) for reference. The actual private key stays only with the user (encrypted in Nostr and possibly also stored securely in the backend or client for later use).  

After this, the user’s “portable wallet” is live on Nostr. Any client with the user’s Nostr key can fetch the kind 17375 and 7375 events to reconstruct the balance, and others can discover how to pay the user via the kind 10019 event.

### `POST /wallet/receive`  
**Purpose:** Add new eCash tokens to the user’s wallet. This can happen in two ways: (a) the user got **Nutzapped** by someone (i.e. someone sent them a token via Nostr event), or (b) the user has a Cashu **token string** (e.g., from a QR code or text) to deposit. Our service can handle both, but the NIP-61 Nutzap flow is the novel part.  

**Process (receiving a Nutzap via Nostr):**  
1. **Detect Incoming Payment:** The backend should check for new `kind:9321` events on the relays the user listens to. In practice, this could be done via a persistent WebSocket subscription or by querying on-demand when the user opens their app or calls this endpoint. For simplicity, you could have the frontend call `/wallet/receive` periodically or after a notification. The backend then uses the Nostr client library to fetch any `kind:9321` events that have a `p` tag matching the user’s Nostr pubkey (the one that was in the sender’s event). Each such event is a payment intended for the user ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=Nutzap%20event)).  
2. **Parse the Nutzap Event:** For each found event, examine its tags. It should have:  
   - A `proof` tag containing a JSON string of the eCash token (amount, `C` (commitment), `id`, and `secret`) ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=kind%3A%209321%2C%20content%3A%20,02eaee8939e3565e48cc62967e2fde9d8e2a4b3ec0081)) ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=,)). Since this token is P2PK-locked to the user’s wallet pubkey, it **cannot be spent by anyone except** the user (even though the event is public).  
   - A `u` tag with the mint URL that issued this token ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=,kind%3A10019)). (We check that it matches our expected mint to avoid any unwanted tokens from unknown mints.)  
   - Likely a `p` tag (the user’s pubkey) and possibly an `e` tag referencing an event (if the payment was for a specific post, similar to zaps).  
   - The event `content` may include a message from the sender (like “Thanks!”), but that’s optional and not needed for processing.  
3. **Redeem the Token from Mint:** To securely add this token to our wallet, we must contact the Cashu mint. The token in the event is still in the form the sender created; we should **swap it into a new token controlled by the user**. Using the Cashu library, call an appropriate method to redeem or reissue the token. Under the hood, this likely involves sending the token’s `secret` (which is P2PK-locked) and the user’s **wallet private key** to the mint, along with a cryptographic proof that the user owns that key (this is done using a DLEQ proof as defined by Cashu’s protocol, so that the mint can verify the lock without learning the key) ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=match%20at%20L369%201,65)). The mint will then issue a fresh token (or the same token unlocked) now bound to the user. In simpler terms: *“Tell the mint I have this coin that Alice locked to my key; mint, please swap it into a normal coin for me.”* If the token is valid and unspent, the mint returns a new token (a new secret and commitment) of the same value, now spendable by the user.  
4. **Update Wallet State:** Now the backend adds this new token to the user’s wallet records on Nostr. It will create a new **Token event** (kind 7375) that includes the received proof. This event’s content is encrypted with the user’s key (NIP-44) so only they can read the details ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=%7B%20,1)) ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=,2%22)). We tag it with the mint URL. We might also include a reference (`tags` or content field) indicating this came from a nutzap (for instance, mark the `e` tag of the original payment as redeemed, or just rely on the spending history event). Publish this kind 7375 event to Nostr so it becomes part of the user’s persisted wallet. Optionally, also record a **spending history event** (kind 7376) to log an incoming transaction ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=1,only%20and%20is%20completely%20optional)) (with details like from whom, amount, timestamp), but this is just for UI/records.  
5. **Acknowledge/Finalize:** Mark the Nutzap event as processed. (NIP-61 doesn’t specify an ack, but you could delete the nutzap event or send a thank-you note via DM or Nostr if desired. Many clients simply leave it as a record of the zap.) In our service, once redeemed, the nutzap event’s token is effectively spent, so it can’t be reused.  
6. **Return Result:** The API can respond with the updated balance or status. The frontend now can query `/wallet/balance` or simply trust that the backend’s response includes new balance.  

If the `receive` endpoint is used to handle a user manually pasting a Cashu token (instead of an automatic nutzap event): the flow is similar minus the Nostr fetching. You’d parse the token string provided in the request, call the mint to verify/redeem it (split it into the user’s own token), then post a kind 7375 event to record it. The rest (updating balance, etc.) is the same.

### `POST /wallet/spend`  
**Purpose:** Spend some of the user’s eCash balance. This could mean sending a Nutzap to another Nostr user (as a tip or payment), or potentially withdrawing to a raw token or Lightning payment. We’ll focus on the Nutzap-to-user scenario, as that’s the NIP-61 use case.  

**Process (sending a Nutzap to another user):**  
1. **Input:** The frontend should provide the recipient’s identifier and an amount. The recipient could be identified by their Nostr pubkey (e.g., npub... or hex pubkey) or some username that the backend can resolve to a pubkey. Also the amount (in sats) to send. Optionally, an `event_id` if this payment is for zapping a specific post (so we can reference it).  
2. **Fetch Recipient’s Info (kind 10019):** The backend will look up the recipient’s **Nutzap info event** (10019) on Nostr ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=%7B%20,pubkey%3E%22%20%5D)). This tells us *how* to pay them: which relays to send the event to, which mint they accept, and the pubkey to lock the token to ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=,lock%20receiving%20nutzaps)). Using the Nostr library, query for kind 10019 events authored by that user’s pubkey. Parse out the `mint` and `pubkey` tags. In our simple scenario, we expect the mint to be the same one we use (if not, we might have a problem – but we assumed a single mint network). Let’s assume the recipient’s trusted mint matches ours (or is among our options). Extract the recipient’s **P2PK public key** from the event (the key their wallet will use to redeem).  
3. **Prepare the Token (Cashu):** Now we need to create an eCash token of the specified amount that’s locked to the recipient’s key. Using the Cashu wallet library in the backend, we do the following:  
   - Check the user’s available tokens (from their kind 7375 events or a cached balance) to ensure they have at least that amount. If not, return an error (insufficient balance).  
   - If they have enough, choose tokens to cover the amount. If the user has an exact token of that amount, great. If not, the library will likely handle **splitting** tokens. For example, if the user has a 1000 sat token and wants to send 300 sats, the library will split it into a 300 sat token and a 700 sat “change” token. This involves calling the mint’s `/split` API: sending one or more of the user’s proofs to the mint along with new blind requests for the desired denominations (one for 300 sat locked to recipient, one for 700 sat back to the user).  
   - In the split request, we specifically request one output be P2PK-locked to the recipient’s pubkey. The Cashu protocol supports this (using NUT-11 extension). We provide the recipient’s pubkey (with the required prefix – NIP-61 says to prefix it with `02` for compatibility ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=recipient.%20The%20outputs%20are%20P2PK,event)), basically ensuring it’s encoded as a valid curve point). The mint will create a new blind signature that incorporates that pubkey lock, and return a token whose `secret` field is of the form `["P2PK", {nonce:..., data:...}]` rather than a simple random secret ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=match%20at%20L275%20,)). The library likely abstracts this: you might call something like `wallet.mintP2PK(amount, recipientPubKey)` or set a parameter on the split.  
   - The result from the mint will be: the **P2PK-locked token** for the recipient (amount = what we want to send), and possibly some **change tokens** for any leftover amount returned to the sender. The original proofs used are now spent (the mint will mark them as spent in its DB).  
4. **Publish Nutzap Event (kind 9321):** Construct a new Nostr event of kind 9321 representing this payment ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=Nutzap%20event)). Include the following in the event:  
   - `kind`: 9321, `pubkey`: the sender’s Nostr pubkey (user’s pubkey), `created_at`: now, etc.  
   - `tags`: 
     - a **`p` tag** with the recipient’s Nostr pubkey (to denote who this is for). This is crucial so the recipient’s client knows this event targets them.  
     - an **`e` tag** with the ID of the post being zapped (if provided, and if you want to attach the payment to an event, like a like/tip to a specific note). This is optional but common for “zaps”.  
     - a **`proof` tag** containing the JSON of the eCash token we are giving. This is the output from the mint we got in step 3. For example, it might look like: `["proof", "{\"amount\":300,\"C\":\"<commitment>\",\"id\":\"<id>\",\"secret\":\"[\\\"P2PK\\\",{\\\"nonce\\\":\\\"...\\\",\\\"data\\\":\\\"...\\\"}]\"]"]` – essentially the token info serialized ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=,)). (The secret includes the P2PK lock information, ensuring only the recipient’s privkey can unlock it.)  
     - a **`u` tag** with the mint URL used ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=,kind%3A10019)), so the recipient knows which mint these tokens come from.  
     - (Optional) You might include an `amount` tag or put the amount in the content for easy reference, but since the proof has the amount, it’s not strictly necessary.  
   - `content`: You can put a user-friendly message here, e.g. “Zap 300 sats” or “Thanks for your post!”. This content is not vital to processing, but it’s nice for the recipient to read.  
   Sign this event with the user’s Nostr key and send it to the relays the recipient specified (from their 10019 event). You can also send to your default relays for completeness.  
5. **Update Sender’s Wallet State:** Now update the user’s own wallet, since they just spent some coins. The original proofs used are now spent, and if there was change returned, new proofs for that change were received. Following NIP-60, you should mark the old token events as spent and create new token event(s) for any new change. For example: if the user spent a 1000 sat token to produce a 300 sat to Bob and 700 sat back, you would:  
   - Publish a **delete event** (kind 5) for the old 1000-sat token event (with a tag `["k","7375"]` as per NIP-60 ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=When%20one%20or%20more%20proofs,field)) to indicate a token event deletion).  
   - Publish a new **token event (7375)** for the 700 sat change, with content listing that new proof and a `del` field referencing the old token’s event id ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=%2F%2F%20tokens%20that%20were%20destroyed,%5B%5D)). (If no change, then you just delete the old and don’t need a new one, or if you combined multiple tokens, you’d handle accordingly. For simplicity, assume one input one output for change.)  
   This bookkeeping ensures the Nostr-stored state reflects the current unspent proofs. The user’s balance on Nostr is now reduced by the sent amount. Also optionally log a spending history event (7376) describing an outgoing payment of 300 sats to Bob.  
6. **Return Result:** The backend responds indicating success. You might include the new balance or the event ID of the Nutzap for reference. The user’s frontend can now show that the payment was sent. The actual value transfer happens off-chain via the token we posted – the recipient will claim it at the mint.  

### Other Considerations  
- **Balance Calculation:** The user’s balance is the sum of amounts in their current unspent proofs (kind 7375 events). The backend can compute this by decrypting those events from Nostr. A `GET /wallet/balance` could fetch all kind 7375 events for the user (perhaps filtering out those that have been marked in `del` fields as spent) and summing the amounts. This is how the user can see their funds across sessions/clients.  
- **Security:** The Nostr private key should be handled carefully. Ideally, signing of Nostr events happens client-side (the React app) to avoid ever sharing the key with the server. But the backend could manage it if the app trusts it (in a custodial model). Similarly, the wallet’s P2PK private key (for receiving tokens) must be stored encrypted on Nostr and possibly in the backend DB encrypted. When needing to redeem a token, the backend will use that privkey (which it can decrypt using the user’s Nostr key or a symmetric secret derived from it). This is a bit complex – for simplicity, you might decide the backend holds the keys in memory during the session or the user supplies them on each call (less user-friendly). In a real app, consider using something like a browser extension or in-app key storage to sign and maybe to decrypt the wallet content locally. For our design, we assume the backend can get the needed keys (perhaps the user logs in with their Nostr key, which is then used for the session).  
- **MongoDB usage:** You might store a copy of the user’s encrypted proofs in MongoDB for quick access or maintain flags for spent tokens, but since Nostr events already keep track (with `del` tags and delete events), you can also derive state from the relays. A reasonable approach: on each action, fetch latest events from Nostr, reconcile with any cached state in Mongo, and then update Mongo. This way if the cache and Nostr diverge, Nostr (being the source of truth) prevails.  

## Example Walkthrough  
**Creating a Wallet:** Alice opens the Nostr client app for the first time and hits “Enable eCash Wallet.” The app calls `POST /wallet/create` with Alice’s Nostr auth. The backend generates a new wallet keypair, publishes Alice’s kind 17375 wallet event (with her mint info and encrypted privkey) and a kind 10019 info event (with her mint, relay, and pubkey for receiving) ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=%5B%20,pubkey%3E%22%20%5D%20%5D)). Alice’s app now shows she has a Cashu wallet set up (balance 0). The data is stored on Nostr, so if Alice logs in on another device and the app queries Nostr, it will find her wallet event and know she has a wallet with that mint.  

**Receiving a Nutzap:** Bob likes Alice’s post and wants to tip 5 sats. Bob’s client finds Alice’s 10019 info (perhaps via her Nostr profile or a lookup) and sees she uses `mintX` and her P2PK pubkey. Bob’s app calls its `/wallet/spend` to create a nutzap. Bob’s Cashu wallet splits 5 sats from his balance, locking it to Alice’s pubkey, and Bob’s client posts a kind 9321 event with the token. Later, Alice opens her app and hits “Refresh” (or an automatic background job runs). Alice’s backend queries the relay for any `9321` events tagged for Alice. It finds Bob’s payment event containing a 5 sat token. The backend calls the mint’s API to redeem that token to Alice’s wallet (proving it has Alice’s privkey). The mint responds with a new 5 sat token secret for Alice. The backend then deletes any old events if needed (none in this case, since it’s just an addition) and posts a new kind 7375 token event storing Alice’s new 5 sat proof (encrypted). Alice’s balance is now 5 sats. The next time she checks, the app shows “5 sats” in her wallet. Bob’s token event remains on Nostr (public but now effectively spent). Alice could optionally send Bob a thank-you note, but that’s outside the protocol.  

**Spending (Nutzap Out):** Now Alice wants to send 3 sats to Charlie’s Nostr pubkey (perhaps to donate or pay for something). She hits “Send 3 sats to Charlie” in her app, which calls `POST /wallet/spend` with Charlie’s npub and amount=3. The backend looks up Charlie’s kind 10019 info to get his mint (luckily also `mintX`) and P2PK pubkey. Alice’s wallet has 5 sats; it splits them into 3 sats for Charlie and 2 sats change. The backend gets a 3 sat P2PK token for Charlie from the mint and a 2 sat token back for Alice. It then publishes a kind 9321 event with the 3 sat token to the relays Charlie specified. It also updates Alice’s Nostr wallet state: the old 5 sat proof is marked spent (deleted) and a new 2 sat token event is posted for her remaining balance. Charlie’s client, upon checking, will find the nutzap event and redeem the 3 sats into his own wallet (similar to how Alice did earlier). Alice’s app now shows 2 sats left.  

Throughout these flows, the heavy lifting of token management is done by the Cashu protocol (mint and wallet operations), while Nostr acts as a message and storage layer to coordinate the exchange and state.

## Suggested Libraries and Tools  
You don’t have to implement the crypto and protocol logic from scratch – there are libraries for both Nostr and Cashu that can greatly speed up development:

- **Cashu TS (TypeScript library)** – An open-source library for Cashu eCash operations ([GitHub - cashubtc/cashu-ts: A TypeScript library for building Cashu wallets](https://github.com/cashubtc/cashu-ts#:~:text=Cashu%20TS%20is%20a%20JavaScript,Cashu%20wallets%20written%20in%20Typescript)). It supports connecting to a mint, minting and splitting tokens, sending/receiving tokens, checking spent tokens, and even the P2PK (NUT-11) features ([GitHub - cashubtc/cashu-ts: A TypeScript library for building Cashu wallets](https://github.com/cashubtc/cashu-ts#:~:text=Wallet%20Features%3A)). Using this library, you can create a `CashuWallet` instance in your Node backend, configure it with the mint URL, and then call high-level methods for issuing tokens or verifying tokens. This will save you from manually crafting mint HTTP calls and handling cryptographic blinding. The **Nutstash** web wallet (TypeScript) is an example project that uses this library ([awesome-cashu/README.md at main · cashubtc/awesome-cashu · GitHub](https://github.com/cashubtc/awesome-cashu/blob/main/README.md#:~:text=Tor%2C%20supports%20multiple%20mints%2C%20and,nostr%20integration%20for%20contacts%20and)) ([awesome-cashu/README.md at main · cashubtc/awesome-cashu · GitHub](https://github.com/cashubtc/awesome-cashu/blob/main/README.md#:~:text=,integration%20for%20contacts%20and%20messaging)), so you can refer to its code for practical usage patterns.  

- **nostr-tools (JavaScript library)** – A well-known library for building Nostr clients in Node/JS. It can generate keys, sign events, validate signatures, encrypt/decrypt content (it has NIP-04 encryption, and NIP-44 can be handled similarly), and manage relay connections ([nostr-tools - Codesandbox](http://codesandbox.io/p/github/Kamchybekk/nostr-tools#:~:text=Creating%2C%20signing%20and%20verifying%20events,tools%27%20let%20event)). For instance, you can use `nostr-tools` to create and sign the NIP-60/61 events (17375, 7375, 9321, etc.) with the user’s key, and to subscribe to relays for new events (like listening for kind 9321 nutzaps addressed to the user). Another option is **Nostr NDK**, a higher-level dev kit that simplifies managing multiple relays and subscriptions, but to keep things simple, `nostr-tools` might suffice.  

- **Other Tools:** For integrating Nostr in a Node backend, you might also look at packages like `nostr-relaypool` or `nostr-fetch` which help query multiple relays easily. On the Cashu side, besides cashu-ts, there are Python and Rust implementations; since you’re in a Node/MERN context, the TS library is most appropriate.  

By leveraging these libraries and following the outlined design, you can implement a straightforward eCash wallet service. The result will allow users of your MERN stack Nostr client to seamlessly receive and send eCash (satoshis) through Nostr – all while storing their “coins” in Nostr (Nutstash) and enabling one-click tipping via Nutzaps. This keeps the user experience simple and avoids external dependencies (no separate databases or complex setups beyond the Nostr relays and a Cashu mint). The focus is on clarity: each step (create, receive, spend) is clearly defined and traceable, making the system easier to build and maintain even if it's not fully optimized for every edge case. 

**Sources:** NIP-60 and NIP-61 specifications for wallet and nutzap event formats ([nips/60.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/60.md#:~:text=1,only%20and%20is%20completely%20optional)) ([nips/61.md at master · nostr-protocol/nips · GitHub](https://github.com/nostr-protocol/nips/blob/master/61.md#:~:text=,kind%3A10019)), and the Cashu and Nostr library references ([GitHub - cashubtc/cashu-ts: A TypeScript library for building Cashu wallets](https://github.com/cashubtc/cashu-ts#:~:text=Wallet%20Features%3A)) for implementation details.